/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fillit.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ssoraka <marvin@42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/04/23 09:44:51 by ssoraka           #+#    #+#             */
/*   Updated: 2019/04/23 09:44:51 by ssoraka          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */



int		main()
{
	char **mass;
	char **arr;

	**mass = чтение_данных();//
	if (проверка_валидности(mass) == 1)
	{
		arr = обработка_данных(mass);
		поиск_наименьшего_квадрата(arr);
	}
	else
		ft_putstr("error");
	return (0);
}

void	поиск_наименьшего_квадрата(char **arr)
{
	int		summ;
	int		len;//сторона квадрата
	char	**map;

	n = количество_фигур;
	k = 0; //номер_текущая_фигура;
	summ = 4 * n;
	len = корень_округленный_вверх(summ);
	map = создание_пустой_карты(len);

	while (размещение_фигур_в_квадрате(arr, len, map, n, 0) == 0)
	{
		len++;
		удаление_карты(map);
		map = создание_пустой_карты(len);
	}
	выводим_на_печать_результат(map);
}


int		размещение_фигур_в_квадрате(char **map, char **arr, int len, int n, int k)
{
	//n = количество_фигур;
	//k = текущая_фигура;
	if (k > n)
		return (1);//смогли расположить все фигуры в текущем квадрате
	if (поиск_места_для_текущей_фигуры(map, arr, len, n, k + 1) == 1)
		return (1);
	else
		return (0);//не смогли расположить все фигуры в текущем квадрате
}


int		поиск_места_для_текущей_фигуры(char **map, char **arr, int len, int n, int k)
{
	int i;
	int j;

	i = 0;
	j = 0;
	while (i < len - высота_фигуры)
	{
		j = 0;
		while (j < len - ширина_фигуры)
		{
			if (проверка_пересечений(map, arr[k], i, j) == 0)
			{
				//номер фигуры k отправляем для выюора буквы
				добавление_текущей_фигуры_на_карту(map, arr, i, j ,k);
				if (размещение_фигур_в_квадрате(map, arr, len, n, k + 1) == 1)
					return (1);
				else
					стираем_текущую_фигуру_с_карты(map, arr[k], i, j);
			}
			j++;
		}
		i++;
	}
	return (0);
}





/*
int рекурсивная_функция(char **arr, int len, char **map, int n, int k)
{
	int k;

	n = количество_фигур;
	while (k < n)
	{
		i = 0;
		while (i < len)
		{
			j = 0;
			while (j < len)
			{
				if (проверка_пересечений(arr[n], map) == 0)
				{
					добавление_текущей_фигуры_на_карту(map, arr[n], i, j);
					if (рекурсивная_функция(arr, len, map, n, k + 1))
						return (1);
					else
						стираем_текущую_фигуру_с_карты(map, arr[n], i, j);
				}
				j++;
			}
			i++;
		}
	}
}
*/
